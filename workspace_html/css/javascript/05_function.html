<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>


         





        // function 키워드로 시작
        // 함수 이름 (키워드 빼고)
        // (),{} 가 형식
        // () 안에는 전달 받을 내용을 담는 변수들
        // return 키워드를 통해서 값을 돌려줄 수 있다

        // 힘수를 쓰는 이유
        // 1. 정해진 순으로 동작하는 코드의 묶음
        // 2. 코드의 재사용을 편하게 
        let z = 1;


        function add(x,y){ // ()선언을 의미,
                           // 전달 받을 내용을 저장할 변수까지 선언
            let z = x + y;
            console.log(z);

            return z;
        }

        // 지역 변수
        let a = 3;
        let b = 7;
        //add(3,7); // () 실행을 의미, 전달할 내용을 넣을 수 있음 
        let arr3 = add(a, b); // let arr3 = add(3,7); 사용가능 
        console.log('arr3 : ', arr3);


        let k = 3;
        let l = 7;
        add(k, 1);

        // x 라는 이름의 기본 함수
        function x (){

        }

        x();

        // 즉시 실행하는 예제(아직 몰라도 됨)
        ( // ( )안에 함수을 널고
        function y ()
        {  
            console.log(123)  // () 안에 있는 함수를 실행 시킴
        }
        )();

        // 전달인자가 하나인 함수
        let result = sqr(5);
        function sqr(a) { // 함수는 어느 위치에 있어도 실행이 가능함
            let b = a * a;
            return b;
        }

        console.log(result);

        // 전달인자가 없는 함수
        function printInFo(){
            console.log("이름 : 최민수");
            console.log("나이 : 비밀");
        }
        printInFo();

        // 호이스팅



        // 함수 안에서 호출하는 함수

        // add(x,y), sqr(a)
        // x,y를 더해서 제곱하기
        function fnInfn(first, second){
            // console.log(1)
            let result1 = add(first, second);  // TODO : stack 개념 설명
            let result2 = sqr(result1);
            // console.log(2)
            return result2;
        }
        let result3 = fnInfn(1, 2);
        console.log(result3);

        // 전달인자는 순서대로 넘어 오기 때문에
        // 하나만 오면 a에 들어감
        // 그래서 b에만 전달 할 수 없음 // 지정해서 값을 줄수 없다. 일부만 가능
        function sum(a, b){  
            console.log('a : ',a);
            console.log('b : ',b);

            let c;
            if(b){  // false란? : false, undefined, null, 0, ''
                    // true란? : !false
            //  if(b == undefined){
                c = a + a;
            } else{
                c = a + b;
            }

            console.log('c : ',c);
            console.log('isNaN : ',isNaN(c));
            return c;
        }
        sum(1, 2);
        sum('aaa', 3);
        // 전달인자를 하나만 줌
        // 두번째 전달인자를 주지 않아서 undefined
        sum(1);
        sum('a');
        // 아무것도 안줘도 실행 됨
        sum();
        // 전달인자 3개 줌
        // 많이 줘봤자 두개만 씀              
        sum(1, 2, 5); // 5는 의미가 없어서 출력이 안됨

        function sum2(a, b){
            if( a == undefined) a = 0;
            if( b == undefined) b = 0;    

            return a + b;
        }

        // 전달인자가 없는 경우 초기값(기본값) 지정
        function sum3(a = 10, b = 20){
            return a + b;
        }
        let result2 =  sum3();
        console.log('sum3() 호출 결과 :',result2); // 30
        console.log('sum3() 호출 결과 :',sum3(50)); // 70
        console.log('sum3() 호출 결과 :',sum3(50,60)); // 110

        function sum4(){
            // arguments : 전달인자 모두를 배열로 받기 
            console.log(arguments);

            for(let i2=0; i2< arguments.length; i2++){
                console.log(i2, arguments[i2]);
            }
        }
        sum4(1, 2, 3, 4);

        // ... : 스프래드spread 연산자
        //       지정하지 않는 arguments들을 배열처리 해줌
        //       마지막 전달인자에만 적용할 수 있다
        // 마치 splice(2,4, 'a', 'b', 'c')
        function sum5(start, count, ...el){
            console.log(start, count,el);
        }
        sum5(1, 2, 3, 4, 5);

        let aa =[100, 200];
        console.log(aa);

        // console.log(100,200);
        console.log(...aa);


        // sum(aa[0], aa[1]);
        sum(...aa);

        let a5 = "console.log(123)";
        eval(a5);  // 글씨를 javascript로 실행
        eval("let a"+ 6 +'= 60');

        // js의 변수에는 아무거나 담을 수 있다. 심지어 함수도
        let sum55 = sum5;
        sum55(2, 3, 4, 5);
        let cLog = console.log;
        cLog(12345);

        function sum5(){
            console.log('올 뉴 sum5');
        }
        sum5();

        var a7 =2;
        var a7 = 20;
        console.log('befor', typeof sum5);
        // sum5 = 1;  // 함수가 아니라 변수로 변함
        //  함수명도 변수 취금하기 때문에 이런 경우 sum5는 그냥 1을 담은 변수가 된다
        // sum(1, 2) // sum5는 더이상 함수가 아님
        console.log('after', typeof sum5);

        function minus(x, y){
            console.log('minus 실행')
            return x-y;
        }

        // 전달인자로 함수를 전달할 수 있다
        // 전달된 함수를 콜백 함수 cb (callback)라고 한다.
        function study( cb ){
            console.log('1 ~ 2시간 정도 공부함')

            if(typeof cb == "function"){
            let remain = cb(10, 2);
            console.log(' 남은 공부 시간 ', remain);
                  }
        }
        study(minus);

        // 익명 함수
        // 이름이 없다
        let fn1 = function(){
            console.log('fn1 실행');
        }
        fn1();

        // 예를 들어 
        // 이런 함수가 콜백으로 딱 한번밖에 안쓰이는 경우
        function times(a, b){
            return a*b;
        }
        study(times);   // 이렇게 할 수도 있다

        let times2 = times;
        study(times2);

        let times3 = function(a, b){
            return a*b;
        }
        study(times3);

        study( function(a, b){
            return a*b;
        })

        // setTimeout : 첫번째 전달인다로 실행할 함수
        //              두번째 전달인다로 1/1000초 단위의 시간을 전달
        // 두번째 전달인자로 시간 이후에 callback 실행
        // 실행하면 예약 번호를 return
        
        // let idx = setTimeout(fn1, 3*1000); 

        // setTimeout(fn1, 3*1000); // 예약
        let idx = setTimeout(function (){ // idx가 먼저 실행 후 setTimeout이 실행됨
            console.log('fn1 실행');
        }, 3*1000);
        //24*60*60*1000
        console.log('idx : ',idx);
        // 예약한 내용 취소 
        clearTimeout(idx); // 예약을 취소하는 기능
        
        // 지정된 ms(밀리초) 이후마다 반복해서 callback 함수 실행
        let idx2 = setInterval(function(){
            console.log('setInrterval 실행')
        }, 1*1000);
    
        setTimeout(function(){ 
            console.log('setInterval 종료');
            clearInterval(idx2); // 반복을 멈춤
        }, 2.5*1000);

        console.log(new Dste().getTime());
    </script>
</head>
<body>
    
</body>
</html>